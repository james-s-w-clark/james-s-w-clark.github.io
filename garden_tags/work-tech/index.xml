<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>work, tech on James' Digital Garden</title><link>https://idiosapps.github.io/garden_tags/work-tech/</link><description>Recent content in work, tech on James' Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><copyright>James Clark Â©</copyright><lastBuildDate>Tue, 06 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://idiosapps.github.io/garden_tags/work-tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Career - Disney Streaming - What I Done</title><status>seeding</status><link>https://idiosapps.github.io/garden/disney-what-i-done/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://idiosapps.github.io/garden/disney-what-i-done/</guid><description>&lt;p>Outside of usual sprint project work (Scala Functional Programming microservices), I enjoyed dabbling with different bits of tech and ideas (mostly tech/way of working related) in my time at Disney Streaming so far!&lt;/p>
&lt;h1 id="migrating-our-team-to-kubernetes">Migrating our team to Kubernetes&lt;/h1>
&lt;p>We were running our applications on a bespoke ECS-like platform - which worked fairly well, apart from deployments regularly failing due to nodes being too small to fit pods onto. It has health checks, self-healing properties, etc. like Kubernetes - but you can&amp;rsquo;t easily &lt;code>ssh&lt;/code> into pods even in non-prod environments easily. There&amp;rsquo;s more reasons for the move, but basically there&amp;rsquo;s a company-wide effort to move to EKS.&lt;/p>
&lt;p>I loved using Kubernetes (with k9s!) at Sainsbury&amp;rsquo;s, so I volunteered to lead this migration project for our team. Here&amp;rsquo;s some things I learned whilst leading this:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A shared knowledge base such as Google Docs works great. We captured key meeting notes, decisions, diagrams, etc. here.&lt;/p>
&lt;ul>
&lt;li>Anyone can get up to speed quickly&lt;/li>
&lt;li>Easy to ask questions, add comments&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Creating a &amp;ldquo;team training Slack channel&amp;rdquo; for a new tech domain works great&lt;/p>
&lt;ul>
&lt;li>As you work through the training, questions, problems, and solutions crystallise&lt;/li>
&lt;li>All information is contained neatly in the channel, not spread all over various places
&lt;ul>
&lt;li>It&amp;rsquo;s easier to collate key points and give feedback to the course owners&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>You can expand the channel beyond just your team, sharing the benefits&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>For real-time knowledge sharing, encourage various people to take tickets on the work. Pair with them for smooth KT&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In refinement, it can be great to call out a ticket as a pairing ticket - a &amp;ldquo;ðŸ&amp;rdquo; emoji in the title is a nice reminder that some felt they had something new to learn from it&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="jenkins">Jenkins&lt;/h1>
&lt;ul>
&lt;li>Consider adding a &amp;ldquo;notes&amp;rdquo; text parameter to some builds. Even if you don&amp;rsquo;t update the build description with this, it can be very useful to know why some builds were run (e.g. manual perf testing of a branch - what change, what is expected)&lt;/li>
&lt;li>For performance tests, put time-stamped links to observability platforms (DataDog, Grafana, etc.) in the output - it really helps the ergonomics of diagnosing any issues. Lower barrier to entry helps keep performance high!&lt;/li>
&lt;li>Be mindful of how many messages you&amp;rsquo;re sending to Slack, and where. If there&amp;rsquo;s just a little traffic, it can go to a visible team chat. If it&amp;rsquo;s noisy, it&amp;rsquo;ll probably go to a chat where people don&amp;rsquo;t look as often!&lt;/li>
&lt;/ul>
&lt;h1 id="github-actions">GitHub Actions&lt;/h1>
&lt;p>Apart from linting, auto-fixing, formatting, etc. there are some really cool things you can do with GHA and GH&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Have a fairly complex/tedious workflow for e.g. building docker images and performance testing them on a branch? Use ChatOps to listen to a command and let an Action do it for you&lt;/p>
&lt;ul>
&lt;li>It can reply with a comment, linking to the builds, perf tests, dashboards, etc.&lt;/li>
&lt;li>It can describe what process it is doing, for more explicit documentation&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Use Chinthakagodawita&amp;rsquo;s &lt;a href="https://github.com/chinthakagodawita/autoupdate">autoupdate&lt;/a> action to keep PR&amp;rsquo;s up-to-date with the &lt;code>main&lt;/code> branch&lt;/p>
&lt;ul>
&lt;li>If you have &lt;code>auto merge&lt;/code> enabled, you can use the &lt;code>PR_FILTER&lt;/code> of &lt;code>auto_merge&lt;/code>
&lt;ul>
&lt;li>Done reviewing 5 PRs? Hit auto merge on them, and this will keep them merging until they&amp;rsquo;re all done!&lt;/li>
&lt;li>Without this, you&amp;rsquo;d have to wait and press &amp;ldquo;merge from main&amp;rdquo; four times. That could be like 10-30 minutes being distracted!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Open source contributions:&lt;/p>
&lt;ul>
&lt;li>Coursier&amp;rsquo;s &lt;code>setup-action&lt;/code> is &amp;ldquo;A GitHub Action to install Coursier and use it to install Java and Scala CLI tools.&amp;rdquo;. It can set up various Java verisons and distributions.
&lt;ul>
&lt;li>We use Amazon Corretto at work, and AWS. I [added Corretto to the jvm-index repo](&lt;a href="https://github.com/coursier/setup-action">https://github.com/coursier/setup-action&lt;/a> &lt;a href="https://github.com/coursier/jvm-index/blob/master/src/Corretto.scala)">https://github.com/coursier/jvm-index/blob/master/src/Corretto.scala)&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="docusaurus">Docusaurus&lt;/h1>
&lt;p>I was familiar with Hugo&amp;rsquo;s Doks static site generator, and was happy to try a new SSG here: Docusaurus.&lt;/p>
&lt;p>We were on Docusaurus 1, and we had a lot of complexity with the sidebar, document ordering, etc.. - so I was happy to simplify things and upgrade us to Docusuaurs 2. Here&amp;rsquo;s a few tips:&lt;/p>
&lt;ul>
&lt;li>Set up &lt;a href="https://github.com/marketplace/actions/deploy-pr-preview">PR preview&lt;/a>, so non-developers can see what their changes look like
&lt;ul>
&lt;li>You might need to &amp;ldquo;recreate&amp;rdquo; the Action from scratch to avoid nesting (it&amp;rsquo;s a composite action) - see &lt;a href="https://github.com/rossjrw/pr-preview-action/issues/33">this issue&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Consider adding comments to your site, so people can reach out with the context directly above. &lt;a href="https://utteranc.es/">utteranc.es&lt;/a> can help with this&lt;/li>
&lt;li>Add light/dark src/css/custom.css to match the rest of your project&amp;rsquo;s branding&lt;/li>
&lt;li>For user-facing documentation, add a FAQ page. This could save a lot of time helping resolve confusion on your most common questions!&lt;/li>
&lt;/ul>
&lt;h1 id="meetings">Meetings&lt;/h1>
&lt;ul>
&lt;li>Enable closed captions
&lt;ul>
&lt;li>Having the auto-generated subtitles should be accurate enough to help some of your team follow the conversation&lt;/li>
&lt;li>If the auto-generated subtitles are garbage, you probably need to spend some budget on upgrading microphones. If the computer can&amp;rsquo;t understand you, maybe humans are having an issue too!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="calendar">Calendar&lt;/h1>
&lt;ul>
&lt;li>If a meeting is recorded, but a link to the recording in the invite. It gives a real home to the recording, rather than just a Slack message that gets lost. Helpful for people coming back from holiday/sickness - can flick through Calendar and get straight into the meetings they need to catch up on&lt;/li>
&lt;/ul>
&lt;h1 id="build-caching">Build caching&lt;/h1>
&lt;p>Compiling your apps from scratch every time is a waste of time &amp;amp; energy.
Some build tools support delta/partial compilation - if only 1 file in 1000 changed, we can base our compile around that.
GitHub Actions has a few options for caching dependencies, e.g. &lt;a href="https://github.com/actions/cache">https://github.com/actions/cache&lt;/a> or &lt;a href="https://github.com/coursier/cache-action">https://github.com/coursier/cache-action&lt;/a>. That &lt;em>could&lt;/em> help a little.
Some build tools have a remote cache - that&amp;rsquo;s great for quicker builds on CI. But, if you don&amp;rsquo;t have a remote cache - what can you do?&lt;/p>
&lt;p>Our team uses our own &lt;code>mill&lt;/code> build tool container. It already ran some basic checks to check it&amp;rsquo;d work with our project and could initialise some &amp;ldquo;workers&amp;rdquo; - but didn&amp;rsquo;t do any caching. Here&amp;rsquo;s what I did:&lt;/p>
&lt;ul>
&lt;li>Use a wrapper &lt;code>millw&lt;/code>, a bit like &lt;code>gradlew&lt;/code>. This would allow the container to build for any &lt;code>.mill-version&lt;/code>, by downloading the necessary tooling
&lt;ul>
&lt;li>If we merge a build tool upgrade in our main repo, builds would still work without requiring a manual rebuild on the new version of this image. Not technically efficient due to the redownloads of the build tool, but ultimately removing some toil in making things a little smoother for humans.&lt;/li>
&lt;li>Compile, check formatting, fixing, etc. to generate these outputs in &lt;code>out&lt;/code>, as well as downloading dependencies&lt;/li>
&lt;li>To prevent being over-written, run &lt;code>mv /root/build/out /root/out-cache&lt;/code>. In Jenkins jobs for app builds, move this cache back (if the build is parameterised with using the cache). Dependencies cache doesn&amp;rsquo;t need moving.&lt;/li>
&lt;li>The cache doesn&amp;rsquo;t have to be used. It adds some size, but storage is cheap and saved time/energy is valuable. We use it for PR builds (not &lt;code>main&lt;/code> - that&amp;rsquo;s clean), and&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The outcome of this is that, several minutes are shaved off each module (more or less, each microservice) build time. &lt;em>Faster PR compilations means faster PR checks, which means delivering value faster and reducing our mean time to recovery.&lt;/em> It also means faster builds for ChatOps triggering branch builds + perf tests, giving fast feedback on performance critical code changes!&lt;/p>
&lt;p>I was pleased with doing this, as using &lt;code>deltas&lt;/code> like this has seemed awesome to me for a long time. I was amazed as a teenager when one Android custom ROM could deliver OTA updates 10x smaller than anyone else, by using deltas.&lt;/p>
&lt;h1 id="performance-tests">Performance tests&lt;/h1>
&lt;p>In your performance testing platform (we use Gatling), consider what types of test you want to have, and what should be compared:&lt;/p>
&lt;ul>
&lt;li>nightly, load (main)
&lt;ul>
&lt;li>I made them run for longer (why not? nobody is manually testing on the &lt;code>perf&lt;/code> env at 3am)&lt;/li>
&lt;li>I made them run at peak RPS for 75% of the run time (configurable). Previously, only about 20% of the time was at peak RPS. Choose a traffic shape gives your services a proper workout!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>soak (main)
&lt;ul>
&lt;li>Have seen dependencies clash and lead to slow memory leaks; soak tests protect us from this, run over the weekend&lt;/li>
&lt;li>I oversaw various performance test changes around this time after identifying improvements with the team in a post-mortem.&lt;/li>
&lt;li>Here, we basically decrease the load a little bit (75% of nightly) and run for much longer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>load (branch)
&lt;ul>
&lt;li>results could be very far from average results on &lt;code>main&lt;/code>, so have separate simulation to keep your &amp;ldquo;usually good&amp;rdquo; simulations clean&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="git-hooks">Git hooks&lt;/h1>
&lt;p>Git hooks are great - ensure your code is linted/compilable/tested before pushing.
What&amp;rsquo;s even cooler is combining them with interactive CLI tooling like &lt;code>gum&lt;/code> - see my &lt;a href="https://github.com/IdiosApps/gummy-hooks">&amp;ldquo;gummy hooks&amp;rdquo;&lt;/a> examples.&lt;/p>
&lt;ul>
&lt;li>Iterate quicker by using a bash script and just calling it - you don&amp;rsquo;t actually have to do anything with Git to iterate on it.&lt;/li>
&lt;/ul></description></item></channel></rss>